# Day 08: 統合6502 CPUコア

## 学習目標

Day 08では、これまでに作成したすべてのコンポーネントを統合して、完全に動作する6502 CPU coreを実装します。

### 今日学ぶこと

1. **CPUアーキテクチャ統合**
   - データパス設計
   - 制御ユニット実装
   - レジスタファイル管理

2. **命令実行パイプライン**
   - FETCH → DECODE → EXECUTE → MEMORY → WRITEBACK
   - ステートマシン制御
   - 適切なタイミング制御

3. **メモリインターフェース統合**
   - CPUとメモリシステムの接続
   - バス仲裁とタイミング
   - デバッグとモニタリング

4. **実際の6502プログラム実行**
   - テストROMプログラム
   - 命令セットの動作確認
   - パフォーマンス最適化

## 実装内容

### 1. CPU Core (`cpu_core.sv`)

完全な6502 CPUコア：

```systemverilog
// 主要コンポーネント
// - cpu_datapath: ALU、レジスタ、マルチプレクサ
// - cpu_control_unit: 命令デコードと実行制御
// - status_register: プロセッサステータス管理
```

### 2. CPU Datapath (`cpu_datapath.sv`)

データフロー制御：
- ALU入力選択（A/X/Y/memory）
- レジスタデータソース選択
- ALUとレジスタファイルの統合

### 3. Control Unit (`cpu_control_unit.sv`)

命令実行制御：
- 5ステートマシン実装
- アドレッシングモード制御
- メモリアクセス調停

### 4. Register File (`cpu_registers.sv`)

6502レジスタセット：
- A, X, Y レジスタ
- プログラムカウンタ（PC）
- スタックポインタ（SP）

### 5. Test ROM (`test_rom.sv`)

包括的なテストプログラム：
- 基本ロード/ストア操作
- 算術・論理演算
- レジスタ転送
- スタック操作
- 分岐・ジャンプ
- サブルーチン呼び出し

## CPUステート

### 実行サイクル

1. **FETCH**: PC位置から命令をフェッチ
2. **DECODE**: オペランドを読み取り（必要に応じて）
3. **EXECUTE**: 有効アドレス計算、制御信号生成
4. **MEMORY**: メモリアクセス実行
5. **WRITEBACK**: 結果をレジスタに書き戻し

### クロック制御

スイッチで制御可能なCPUクロック速度：
- `00`: 最低速度 (1.69MHz) - デバッグ用
- `01`: 低速 (3.375MHz) - 観察用
- `10`: 中速 (6.75MHz) - 通常動作
- `11`: 最高速度 (27MHz) - フル性能

## テストプログラム

ROMに格納された包括的なテストシーケンス：

### 基本テスト
1. **ロード/ストア**: `LDA #$42`, `STA $80`
2. **算術**: `ADC`, `SBC` 操作
3. **論理**: `AND`, `OR`, `EOR` 操作
4. **シフト**: `ASL`, `LSR` 操作

### 高度なテスト
5. **比較**: `CMP` 命令とフラグ設定
6. **レジスタ転送**: `TAX`, `TAY`, `TXA`, `TYA`
7. **スタック**: `PHA`, `PLA` 操作
8. **制御フロー**: `JMP`, `JSR`, `RTS`

### 実用的なテスト
9. **ループ**: カウンタ付きループ実装
10. **I/O**: スイッチ読み取り
11. **メモリテスト**: パターン書き込み/読み取り

## ビルドと実行

### 必要なファイル

```
day08_completed/
├── cpu_core.sv              # メインCPUコア
├── cpu_datapath.sv          # データパス
├── cpu_control_unit.sv      # 制御ユニット
├── cpu_registers.sv         # レジスタファイル
├── test_rom.sv              # テストプログラムROM
├── top.sv                   # 統合システム
├── tb_cpu_core.sv           # テストベンチ
├── Makefile                 # ビルドシステム
└── README_ja.md             # この文書

依存ファイル:
├── day05_completed/addressing_mode_calculator.sv
├── day06_completed/cpu_alu.sv
├── day06_completed/cpu_decoder.sv
├── day06_completed/status_register.sv
└── day07_completed/memory_*.sv
```

### ビルドコマンド

```bash
# Tang Nano 9K用ビルド
make tang_nano_9k

# Tang Nano 20K用ビルド
make tang_nano_20k

# シミュレーション実行
make run_sim

# FPGAへの書き込み
make program_9k    # Tang Nano 9K
make program_20k   # Tang Nano 20K
```

## デバッグ出力

Tang NanoのピンでモニターできるCPU状態：

### レジスタ状態
- `debug_reg_a[7:0]` - アキュムレータ
- `debug_reg_x[7:0]` - Xレジスタ
- `debug_reg_y[7:0]` - Yレジスタ
- `debug_reg_sp[7:0]` - スタックポインタ
- `debug_reg_pc[15:0]` - プログラムカウンタ
- `debug_status_reg[7:0]` - ステータスレジスタ

### 実行状態
- `debug_opcode[7:0]` - 現在の命令
- `debug_cpu_state[2:0]` - CPUステート
- `debug_mem_addr[15:0]` - メモリアドレス
- `debug_mem_data[7:0]` - メモリデータ

## 実行例

### 初期化後のCPU状態

```
PC=$C000: プログラム開始
A=$00 X=$00 Y=$00 SP=$FF: レジスタ初期値
Status=$24: I=1, unused=1, others=0
```

### テストプログラム実行

```
PC=$C000: LDA #$42    → A=$42
PC=$C002: STA $80     → [$0080]=$42
PC=$C004: LDA #$84    → A=$84
PC=$C006: STA $81     → [$0081]=$84
PC=$C008: LDA $80     → A=$42
PC=$C00A: CLC         → Status=$20 (C=0)
PC=$C00B: ADC $81     → A=$C6, Status=$A0 (N=1)
```

## 学習ポイント

### アーキテクチャ統合

1. **モジュラー設計**: 各コンポーネントの独立性
2. **インターフェース標準化**: 一貫した信号命名
3. **階層的構造**: トップダウン設計
4. **再利用性**: 前のdayのコンポーネント活用

### 実行制御

1. **ステートマシン**: 明確な状態遷移
2. **タイミング制御**: 適切なクロック管理
3. **エラー処理**: 不正状態の検出
4. **デバッグ性**: 内部状態の可視化

### パフォーマンス

1. **クロック効率**: 最小サイクル数での実行
2. **メモリ効率**: 適切なメモリアクセスパターン
3. **リソース効率**: FPGA資源の最適使用

## トラブルシューティング

### よくある問題

1. **CPUが動かない**
   - リセット信号確認
   - クロック供給確認
   - 初期PC値確認（$C000）

2. **命令が正しく実行されない**
   - デコーダ出力確認
   - ALU操作確認
   - メモリインターフェース確認

3. **レジスタ値が異常**
   - ライトイネーブル信号確認
   - データパス接続確認
   - タイミング問題調査

## 次のステップ

Day 09では、LCDコントローラーシステムを追加して、CPUの出力を視覚的に表示できるようにします。

## 参考資料

- 6502 CPU アーキテクチャ仕様
- SystemVerilog CPU設計パターン
- FPGAタイミング制約設計
- デバッグとテスト手法